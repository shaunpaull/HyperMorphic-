#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HM Fraction Gearbox — Single-File Reference Implementation (with CRT)
=====================================================================

Adds **industrial-strength CRT recombination** for RNS:
- Classical CRT (pairwise coprime) using modular inverses and full product.
- Garner's algorithm (pairwise coprime) for *mixed‑radix* reconstruction (no huge intermediates).
- Generalized CRT (non‑coprime) with consistency checks; returns (x, lcm) or raises if inconsistent.

(…rest of header unchanged…)
"""

from __future__ import annotations

import argparse
import math
import os
from dataclasses import dataclass
from fractions import Fraction
from typing import Iterable, List, Sequence, Tuple, Optional

import numpy as np
import matplotlib.pyplot as plt

# ---------------------------------------------------------------------
# Utilities
# ---------------------------------------------------------------------

def _clamp_fraction_unit(frac: Fraction) -> Fraction:
    if frac < 0:
        return Fraction(0, 1)
    if frac >= 1:
        return Fraction(10**12 - 1, 10**12)
    return frac

def _as_fraction_unit(x: float | Fraction) -> Fraction:
    if isinstance(x, float):
        x = min(max(x, 0.0), math.nextafter(1.0, 0.0))
        frac = Fraction.from_float(x).limit_denominator(10**9)
    else:
        frac = Fraction(x)
    return _clamp_fraction_unit(frac)

# ---------------------------------------------------------------------
# Mixed-Radix: Fractional part
# ---------------------------------------------------------------------

def _greedy_fraction_digits(frac: Fraction, bases: Sequence[int], depth: Optional[int]) -> Tuple[List[int], Fraction]:
    if not (Fraction(0) <= frac < Fraction(1)):
        raise ValueError("frac must be in [0,1)")
    k = len(bases) if depth is None else min(depth, len(bases))
    r = Fraction(frac)
    digits: List[int] = []
    denom = Fraction(1)
    approx = Fraction(0)
    for i in range(k):
        b = int(bases[i])
        r *= b
        d = int(r)
        if d >= b:
            d = b - 1
        r -= d
        digits.append(d)
        denom *= b
        approx += Fraction(d, denom)
    return digits, approx

def frac_encode_standard(x: float | Fraction, bases: Sequence[int], depth: Optional[int] = None) -> Tuple[List[int], Fraction]:
    frac = _as_fraction_unit(x)
    return _greedy_fraction_digits(frac, bases, depth)

def frac_encode_bijective(x: float | Fraction, bases: Sequence[int], depth: Optional[int] = None) -> Tuple[List[int], Fraction]:
    d0, approx = frac_encode_standard(x, bases, depth)
    return [d + 1 for d in d0], approx

def frac_reconstruct(digits: Sequence[int], bases: Sequence[int], bijective_external: bool = False) -> Fraction:
    k = min(len(digits), len(bases))
    denom = Fraction(1)
    s = Fraction(0)
    for i in range(k):
        b = int(bases[i])
        d = int(digits[i])
        if bijective_external:
            d = d - 1
        denom *= b
        s += Fraction(d, denom)
    return s

# ---------------------------------------------------------------------
# Mixed-Radix: Integer part
# ---------------------------------------------------------------------

def int_encode_standard(n: int, bases: Sequence[int]) -> List[int]:
    if n < 0:
        raise ValueError("Use sign with negative integers")
    if not bases:
        return [0]
    digits_rev: List[int] = []
    x = n
    for b in bases[::-1]:
        q, r = divmod(x, b)
        digits_rev.append(r)
        x = q
    return digits_rev[::-1]

def int_reconstruct(digits: Sequence[int], bases: Sequence[int], bijective_external: bool = False) -> int:
    if len(digits) != len(bases):
        raise ValueError("Integer digits length must match bases length")
    x = 0
    for d, b in zip(digits, bases):
        if bijective_external:
            d = d - 1
        if not (0 <= d < b):
            raise ValueError("Digit out of range for base")
        x = x * b + d
    return x

def int_encode_bijective(n: int, bases: Sequence[int]) -> List[int]:
    return [d + 1 for d in int_encode_standard(n, bases)]

# ---------------------------------------------------------------------
# HM Number
# ---------------------------------------------------------------------

@dataclass
class HMNumber:
    sign: int
    int_digits: List[int]
    frac_digits: List[int]
    bases_int: List[int]
    bases_frac: List[int]
    int_bijective: bool = False
    frac_bijective: bool = True

    def to_fraction(self) -> Fraction:
        ival = int_reconstruct(self.int_digits, self.bases_int, bijective_external=self.int_bijective) if self.int_digits else 0
        fval = frac_reconstruct(self.frac_digits, self.bases_frac, bijective_external=self.frac_bijective) if self.frac_digits else Fraction(0)
        return Fraction(self.sign, 1) * (Fraction(ival, 1) + fval)

    def to_float(self) -> float:
        return float(self.to_fraction())

    def __str__(self) -> str:
        si = "-" if self.sign < 0 else ""
        idig = self.int_digits if self.int_digits else [0]
        fdig = self.frac_digits if self.frac_digits else []
        return f"{si}{idig}.{fdig}  (int_bij={self.int_bijective}, frac_bij={self.frac_bijective})"

def encode_number(x: float | Fraction,
                  bases_int: Sequence[int],
                  bases_frac: Sequence[int],
                  depth_frac: Optional[int] = None,
                  int_bijective: bool = False,
                  frac_bijective: bool = True) -> HMNumber:
    if isinstance(x, float):
        xf = Fraction.from_float(x).limit_denominator(10**9)
    else:
        xf = Fraction(x)
    sign = 1
    if xf < 0:
        sign = -1
        xf = -xf
    ival = int(xf)
    fval = xf - ival
    idigits = int_encode_bijective(ival, bases_int) if int_bijective else int_encode_standard(ival, bases_int)
    fdigits, _ = (frac_encode_bijective if frac_bijective else frac_encode_standard)(fval, bases_frac, depth_frac)
    return HMNumber(sign, idigits, fdigits, list(bases_int), list(bases_frac),
                    int_bijective=int_bijective, frac_bijective=frac_bijective)

# ---------------------------------------------------------------------
# Dynamic switch + C¹-like blend
# ---------------------------------------------------------------------

def smoothstep(t: float) -> float:
    if t <= 0.0: return 0.0
    if t >= 1.0: return 1.0
    return t * t * (3.0 - 2.0 * t)

@dataclass
class BaseFamily:
    name: str
    seq: List[int]

def blend_fractional(x: float | Fraction,
                     A: BaseFamily, B: BaseFamily,
                     depth: int,
                     x0: float = 0.5, band: float = 0.08,
                     blend: bool = True) -> Tuple[Fraction, Fraction, Fraction, float]:
    frac = _as_fraction_unit(x)
    _, aA = frac_encode_standard(frac, A.seq, depth)
    _, aB = frac_encode_standard(frac, B.seq, depth)
    if not blend:
        alpha = 0.0 if float(frac) < x0 else 1.0
    else:
        left, right = x0 - band, x0 + band
        if float(frac) <= left: alpha = 0.0
        elif float(frac) >= right: alpha = 1.0
        else: alpha = smoothstep((float(frac) - left) / (right - left))
    alphaF = Fraction.from_float(alpha)
    approx = (Fraction(1, 1) - alphaF) * aA + alphaF * aB
    return approx, aA, aB, alpha

# ---------------------------------------------------------------------
# Adaptive chooser
# ---------------------------------------------------------------------

def _estimate_error(x: float | Fraction, bases: Sequence[int], depth: int) -> float:
    _, approx = frac_encode_standard(x, bases, depth)
    return abs(float(approx) - float(_as_fraction_unit(x)))

def choose_family_and_depth(x: float | Fraction,
                            families: Sequence[BaseFamily],
                            eps: float = 1e-8,
                            max_depth: int = 12) -> Tuple[BaseFamily, int, float]:
    best: Optional[Tuple[BaseFamily, int, float]] = None
    for fam in families:
        for d in range(1, max_depth + 1):
            e = _estimate_error(x, fam.seq, d)
            if e <= eps:
                if best is None or d < best[1] or (d == best[1] and e < best[2]):
                    best = (fam, d, e)
                break
    if best is None:
        cand = [(fam, max_depth, _estimate_error(x, fam.seq, max_depth)) for fam in families]
        best = min(cand, key=lambda t: t[2])
    return best

# ---------------------------------------------------------------------
# CRT & RNS — industrial implementations
# ---------------------------------------------------------------------

def _egcd(a: int, b: int) -> Tuple[int,int,int]:
    """Extended GCD: returns (g, x, y) such that ax + by = g = gcd(a,b)."""
    if b == 0:
        return (abs(a), 1 if a>=0 else -1, 0)
    g, x1, y1 = _egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)

def _modinv(a: int, m: int) -> int:
    """Modular inverse of a mod m; raises if not invertible."""
    a %= m
    g, x, _ = _egcd(a, m)
    if g != 1:
        raise ValueError(f"No inverse for {a} mod {m} (gcd={g})")
    return x % m

def crt_classical(residues: Sequence[int], moduli: Sequence[int]) -> Tuple[int, int]:
    """
    Classical CRT for pairwise coprime moduli.
    Returns (x, M) with 0 <= x < M, where M=∏ m_i.
    """
    if len(residues) != len(moduli):
        raise ValueError("residues and moduli must have same length")
    n = len(moduli)
    # Check pairwise coprime
    for i in range(n):
        for j in range(i+1, n):
            if math.gcd(moduli[i], moduli[j]) != 1:
                raise ValueError("Moduli are not pairwise coprime; use crt_general or Garner.")
    M = 1
    for m in moduli: M *= m
    result = 0
    for r, m in zip(residues, moduli):
        Mi = M // m
        inv = _modinv(Mi, m)
        result = (result + r * Mi * inv) % M
    return result, M

def garner(residues: Sequence[int], moduli: Sequence[int]) -> Tuple[int, List[int]]:
    """
    Garner's algorithm (pairwise coprime). Returns (x, coeffs) where
    x = coeffs[0] + coeffs[1]*m0 + coeffs[2]*m0*m1 + ... (mixed-radix form).
    """
    if len(residues) != len(moduli):
        raise ValueError("residues and moduli must have same length")
    n = len(moduli)
    for i in range(n):
        for j in range(i+1, n):
            if math.gcd(moduli[i], moduli[j]) != 1:
                raise ValueError("Moduli are not pairwise coprime; use crt_general.")
    coeff = [1]*(n+1)
    const = [0]*(n+1)
    v = [0]*n  # mixed-radix coefficients
    for k in range(n):
        t = ((residues[k] - const[k]) * _modinv(coeff[k], moduli[k])) % moduli[k]
        v[k] = t
        for i in range(k+1, n):
            const[i] = (const[i] + coeff[i]*t) % moduli[i]
            coeff[i] = (coeff[i] * moduli[k]) % moduli[i]
    # reconstruct integer from mixed radix
    x = 0
    base = 1
    for k in range(n):
        x += v[k] * base
        base *= moduli[k]
    return x, v

def crt_general(residues: Sequence[int], moduli: Sequence[int]) -> Tuple[int, int]:
    """
    Generalized CRT for possibly non‑coprime moduli.
    Returns (x, M) where M = lcm(moduli), the minimal modulus;
    raises ValueError if system is inconsistent.
    """
    if len(residues) != len(moduli):
        raise ValueError("residues and moduli must have same length")
    x, m = residues[0] % moduli[0], moduli[0]
    for r, mod in zip(residues[1:], moduli[1:]):
        r %= mod
        g, p, q = _egcd(m, mod)  # p*m + q*mod = g
        if (r - x) % g != 0:
            raise ValueError(f"Inconsistent congruences: x≡{x}(mod {m}), x≡{r}(mod {mod})")
        # Solve m*t ≡ (r-x) (mod mod) with reduced moduli
        t = ((r - x) // g) * _modinv(m // g, mod // g) % (mod // g)
        x = x + m * t
        m = (m // g) * mod  # lcm update
        x %= m
    return x, m

# Convenience wrappers for RNS
def rns_residues(n: int, moduli: Sequence[int]) -> List[int]:
    return [n % m for m in moduli]

def rns_add(a: int, b: int, moduli: Sequence[int]) -> List[int]:
    return [ (ra + rb) % m for (ra, rb, m) in zip(rns_residues(a, moduli), rns_residues(b, moduli), moduli) ]

def rns_mul(a: int, b: int, moduli: Sequence[int]) -> List[int]:
    return [ (ra * rb) % m for (ra, rb, m) in zip(rns_residues(a, moduli), rns_residues(b, moduli), moduli) ]

# ---------------------------------------------------------------------
# Defaults
# ---------------------------------------------------------------------

FAMILY_A = BaseFamily("A_small_increments", [3,5,7,9,11,13,15,17,19,21,23,25])
FAMILY_B = BaseFamily("B_exponential",     [4,8,16,32,64,128,256,512,1024,2048,4096,8192])

# ---------------------------------------------------------------------
# Bench / Tests
# ---------------------------------------------------------------------

def run_bench(depth: int = 8, x0: float = 0.5, band: float = 0.08, save_plots: bool = True, outdir: str = ".") -> dict:
    N = 4000
    xs = np.linspace(0.0, 1.0 - 1e-12, N)
    approx_A = np.empty(N); approx_B = np.empty(N); approx_bl = np.empty(N); approx_hd = np.empty(N)
    for i, xf in enumerate(xs):
        _, aA = frac_encode_standard(xf, FAMILY_A.seq, depth)
        _, aB = frac_encode_standard(xf, FAMILY_B.seq, depth)
        ab, *_ = blend_fractional(xf, FAMILY_A, FAMILY_B, depth, x0=x0, band=band, blend=True)
        ah, *_ = blend_fractional(xf, FAMILY_A, FAMILY_B, depth, x0=x0, band=band, blend=False)
        approx_A[i] = float(aA); approx_B[i] = float(aB); approx_bl[i] = float(ab); approx_hd[i] = float(ah)
    err_A = np.abs(approx_A - xs); err_B = np.abs(approx_B - xs)
    err_bl = np.abs(approx_bl - xs); err_hd = np.abs(approx_hd - xs)
    dx = xs[1] - xs[0]
    der_bl = np.gradient(approx_bl, dx); der_hd = np.gradient(approx_hd, dx)
    mask = (xs >= (x0 - band)) & (xs <= (x0 + band))
    summary = {
        "depth": depth, "x0": x0, "band": band,
        "max_abs_error_A": float(np.max(err_A)),
        "max_abs_error_B": float(np.max(err_B)),
        "max_abs_error_blended": float(np.max(err_bl)),
        "max_abs_error_hard": float(np.max(err_hd)),
        "max_derivative_in_band_blended": float(np.max(np.abs(der_bl[mask]))),
        "max_derivative_in_band_hard": float(np.max(np.abs(der_hd[mask]))),
    }
    plt.figure(figsize=(10,5))
    plt.plot(xs, err_A, label="Error A"); plt.plot(xs, err_B, label="Error B")
    plt.plot(xs, err_bl, label="Error Blended"); plt.plot(xs, err_hd, label="Error Hard-switch")
    plt.xlabel("x"); plt.ylabel("absolute error |approx(x) − x|"); plt.title("HM Fraction Gearbox — Error vs x")
    plt.legend(); plt.tight_layout()
    if save_plots:
        plt.savefig(os.path.join(outdir, "hm_fraction_gearbox_errors.png"), dpi=160)
    plt.close()
    plt.figure(figsize=(10,5))
    plt.plot(xs, der_hd, label="d/dx Hard-switch"); plt.plot(xs, der_bl, label="d/dx Blended")
    plt.xlabel("x"); plt.ylabel("approx derivative"); plt.title("HM Fraction Gearbox — Derivative (Hard vs Blended)")
    plt.legend(); plt.tight_layout()
    if save_plots:
        plt.savefig(os.path.join(outdir, "hm_fraction_gearbox_derivatives.png"), dpi=160)
    plt.close()
    return summary

def run_tests(verbose: bool = True, plots: bool = False) -> None:
    xs = [Fraction(n, 997) for n in range(0, 997, 37)]
    max_delta = 0.0
    for x in xs:
        d0, _ = frac_encode_standard(x, FAMILY_A.seq, depth=8)
        db, _ = frac_encode_bijective(x, FAMILY_A.seq, depth=8)
        rec0 = frac_reconstruct(d0, FAMILY_A.seq[:8], bijective_external=False)
        recb = frac_reconstruct(db, FAMILY_A.seq[:8], bijective_external=True)
        max_delta = max(max_delta, float(abs(rec0 - recb)))
    if verbose:
        print("Bijective parity (fractional) max delta:", max_delta)

    num = encode_number(-123.456, bases_int=[10,10,10], bases_frac=FAMILY_B.seq, depth_frac=8,
                        int_bijective=False, frac_bijective=True)
    if verbose:
        print("Encoded HMNumber:", num)
        print("Roundtrip value:", float(num.to_fraction()))

    # CRT tests
    import random
    # Pairwise coprime set
    mods = [5, 7, 11, 13]
    for _ in range(20):
        x_true = random.randrange(0, math.prod(mods))
        r = [x_true % m for m in mods]
        x_class, M = crt_classical(r, mods)
        x_garner, coeffs = garner(r, mods)
        assert M == math.prod(mods)
        assert x_class % M == x_true % M
        assert x_garner % M == x_true % M
    if verbose:
        print("CRT (classical & Garner) passed on random coprime tests.")

    # Non-coprime generalized CRT tests
    mods2 = [6, 8]  # gcd=2
    # Consistent system: x≡2 (mod 6), x≡10 (mod 8) because both ≡2 mod 2
    xg, Mg = crt_general([2, 10], mods2)
    assert xg % 6 == 2 and xg % 8 == 10 and Mg == (6*8)//math.gcd(6,8)
    # Inconsistent example should raise
    try:
        crt_general([1, 0], mods2)  # 1≠0 mod 2
        raise AssertionError("Expected inconsistency not raised")
    except ValueError:
        pass
    if verbose:
        print("Generalized CRT passed consistency/inconsistency tests.")

    if plots:
        summary = run_bench(depth=8, x0=0.5, band=0.08, save_plots=True, outdir=".")
        if verbose:
            print("Bench summary:", summary)

# ---------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------

def main():
    p = argparse.ArgumentParser(description="HM Fraction Gearbox — dynamic mixed-radix with C¹ blend + CRT")
    sub = p.add_subparsers(dest="cmd", required=True)

    pe = sub.add_parser("encode", help="Encode a real number into HM representation")
    pe.add_argument("--x", type=float, required=True)
    pe.add_argument("--depth", type=int, default=8)
    pe.add_argument("--family", choices=["A","B"], default="B")
    pe.add_argument("--int-bases", type=int, nargs="*", default=[10,10,10])
    pe.add_argument("--bijective-frac", action="store_true")
    pe.add_argument("--bijective-int", action="store_true")

    pb = sub.add_parser("blend", help="Blend A/B families for fractional x with C¹ smoothstep")
    pb.add_argument("--x", type=float, required=True)
    pb.add_argument("--depth", type=int, default=8)
    pb.add_argument("--x0", type=float, default=0.5)
    pb.add_argument("--band", type=float, default=0.08)
    pb.add_argument("--no-blend", action="store_true")
    pb.add_argument("--save", choices=["none","plots"], default="plots")

    pa = sub.add_parser("adaptive", help="Choose family+depth for target error ε")
    pa.add_argument("--x", type=float, required=True)
    pa.add_argument("--eps", type=float, default=1e-8)
    pa.add_argument("--max-depth", type=int, default=12)

    pr = sub.add_parser("rns-add", help="RNS gearwise integer add + recombine via CRT")
    pr.add_argument("--a", type=int, required=True)
    pr.add_argument("--b", type=int, required=True)
    pr.add_argument("--moduli", type=int, nargs="+", required=True)
    pr.add_argument("--algo", choices=["classical","garner","general"], default="classical")

    pm = sub.add_parser("rns-mul", help="RNS gearwise integer mul + recombine via CRT")
    pm.add_argument("--a", type=int, required=True)
    pm.add_argument("--b", type=int, required=True)
    pm.add_argument("--moduli", type=int, nargs="+", required=True)
    pm.add_argument("--algo", choices=["classical","garner","general"], default="classical")

    pt = sub.add_parser("test", help="Run internal tests; optionally generate plots")
    pt.add_argument("--plots", action="store_true")

    args = p.parse_args()

    if args.cmd == "encode":
        fam = FAMILY_A if args.family == "A" else FAMILY_B
        num = encode_number(args.x, bases_int=args.int_bases, bases_frac=fam.seq,
                            depth_frac=args.depth,
                            int_bijective=args.bijective_int,
                            frac_bijective=args.bijective_frac)
        print(num)
        print("Value (Fraction):", num.to_fraction())
        print("Value (float):   ", num.to_float())

    elif args.cmd == "blend":
        approx, aA, aB, alpha = blend_fractional(args.x, FAMILY_A, FAMILY_B, args.depth,
                                                 x0=args.x0, band=args.band, blend=not args.no_blend)
        print(f"approx={float(approx)}  aA={float(aA)}  aB={float(aB)}  alpha_B={alpha}")
        if args.save == "plots":
            summary = run_bench(depth=args.depth, x0=args.x0, band=args.band, save_plots=True, outdir=".")
            print("Saved plots and summary:", summary)

    elif args.cmd == "adaptive":
        fam, depth, err = choose_family_and_depth(args.x, [FAMILY_A, FAMILY_B], eps=args.eps, max_depth=args.max_depth)
        print(f"family={fam.name}  depth={depth}  error≈{err:.3e}")

    elif args.cmd in ("rns-add","rns-mul"):
        moduli = args.moduli
        for m in moduli:
            if m <= 1: raise SystemExit("All moduli must be > 1")
        residues = rns_add(args.a, args.b, moduli) if args.cmd=="rns-add" else rns_mul(args.a, args.b, moduli)
        if args.algo == "classical":
            x, M = crt_classical(residues, moduli)
        elif args.algo == "garner":
            x, _ = garner(residues, moduli); M = math.prod(moduli)
        else:
            x, M = crt_general(residues, moduli)
        print("residues:", residues)
        print("recombined:", x, " modulus:", M)
        print("expected:", ( (args.a + args.b) if args.cmd=='rns-add' else (args.a*args.b) ) % M)

    elif args.cmd == "test":
        run_tests(verbose=True, plots=args.plots)

if __name__ == "__main__":
    main()
