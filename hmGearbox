#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HyperMorphic Math Gearbox — Single-file Reference Suite
=======================================================

This single Python file implements the entire **HyperMorphic (HM) dynamic base/modulus system**:
- Core arithmetic (forward & reverse transforms)
- Reversibility and non-reversibility checks
- Path builders (lossless and adaptive)
- Empirical testers (sampling and full enumeration where feasible)
- A CLI with handy subcommands
- Embedded formal statements & proofs (see PROOFS at bottom)

You can drop this file into a GitHub repo as-is. It has no third-party dependencies.

Quick start (CLI)
-----------------
  python hmgearbox.py run --dims 10 11 12 13 14 15 --trials 300
  python hmgearbox.py build-lossless --k 6 --m-start 9 --multiplier 3 --out lossless_k6_m9x3.json
  python hmgearbox.py run --dims-from-file lossless_k6_m9x3.json --trials 600
  python hmgearbox.py build-adaptive --k 12 --m-start 9 --out adaptive_k12.json
  python hmgearbox.py audit --dims-from-file adaptive_k12.json --csv adaptive_k12_audit.csv
  python hmgearbox.py proofs --out PROOFS.md

Core HM rules
-------------
  b(d) = floor(log2 d) + 1
  m(d) = floor(sqrt d) + 1

Forward stage:  t_i ≡ b_i * t_{i-1}  (mod m_i)
Reverse stage:  t_{i-1} ≡ b_i^{-1} * t_i (mod m_i), then reduce to m_{i-1}

Reversibility (informal)
------------------------
The k-stage pipeline is **lossless** (i.e., bijective on domain Z_{m1}) when:
  (1) gcd(b_i, m_i) = 1 for every stage, and
  (2) the moduli form a **divisibility chain** m1 | m2 | ... | mk.

Otherwise it is compressive (many-to-one) with predictable image size shrinkage.

See the formal theorem statements & proofs in PROOFS at the end of this file.
"""
from __future__ import annotations

import argparse
import json
import math
import random
import sys
from dataclasses import dataclass
from math import gcd
from typing import Dict, Iterable, List, Optional, Sequence, Tuple


# =========================
# Core HM arithmetic
# =========================

def b_of(d: int) -> int:
    """
    Dynamic base: b(d) = floor(log2 d) + 1  (defined for d >= 1).
    """
    if d < 1:
        raise ValueError("b_of: d must be >= 1")
    return int(math.log2(d)) + 1


def m_of(d: int) -> int:
    """
    Dynamic modulus: m(d) = floor(sqrt d) + 1  (defined for d >= 0).
    """
    if d < 0:
        raise ValueError("m_of: d must be >= 0")
    # math.isqrt is exact integer sqrt floor
    return math.isqrt(d) + 1


def inv_mod(a: int, m: int) -> Optional[int]:
    """
    Multiplicative inverse of a modulo m, or None if gcd(a, m) != 1.
    """
    if m <= 0:
        raise ValueError("inv_mod: modulus m must be positive")
    a %= m
    if gcd(a, m) != 1:
        return None
    # Extended Euclidean algorithm
    t, new_t = 0, 1
    r, new_r = m, a
    while new_r != 0:
        q = r // new_r
        t, new_t = new_t, t - q * new_t
        r, new_r = new_r, r - q * new_r
    return t % m


@dataclass
class StageTrace:
    d: int
    b: int
    m: int
    t: int


def forward(v: int, dims: Sequence[int]) -> Tuple[int, Dict]:
    """
    Forward HM pipeline over a sequence of dimensions.
    Returns (t_k, info) where info['trace'] is a list of StageTrace-like dicts.
    """
    t = v
    trace: List[Dict] = []
    for d in dims:
        b_i, m_i = b_of(d), m_of(d)
        t = (b_i * t) % m_i
        trace.append({"d": d, "b": b_i, "m": m_i, "t": t})
    return t, {"trace": trace}


def reverse(tk: int, dims: Sequence[int]) -> Tuple[Optional[int], Dict]:
    """
    Reverse HM pipeline. Returns (v_hat, info).
    If any stage is non-invertible (gcd(b_i, m_i) != 1), returns (None, info).
    """
    if not dims:
        return tk, {"ok": True, "trace": []}
    Bs = [b_of(d) for d in dims]
    Ms = [m_of(d) for d in dims]
    t = tk
    rev_trace: List[Dict] = []
    for i in range(len(dims) - 1, -1, -1):
        b_i, m_i = Bs[i], Ms[i]
        inv_b = inv_mod(b_i, m_i)
        if inv_b is None:
            return None, {
                "ok": False,
                "stage": i,
                "reason": "gcd(b_i, m_i) != 1 (no multiplicative inverse)",
                "trace": rev_trace,
            }
        t_prev = (inv_b * (t % m_i)) % m_i
        rev_trace.append({"i": i, "b": b_i, "m": m_i, "inv_b": inv_b, "t_prev": t_prev})
        if i > 0:
            # reduce to previous modulus
            t = t_prev % Ms[i - 1]
        else:
            # reached original domain Z_{m1}
            return t_prev, {"ok": True, "trace": list(reversed(rev_trace))}
    # Should be unreachable
    return None, {"ok": False, "reason": "unexpected control flow"}


def stage_invertible(d: int) -> bool:
    """True iff a single stage at dimension d is bijective on Z_{m(d)}."""
    return gcd(b_of(d), m_of(d)) == 1


def pipeline_conditions(dims: Sequence[int]) -> Dict:
    """
    Returns:
      - Bs, Ms
      - per_stage_invertible: [bool,...]
      - divisibility_chain: bool (m1 | m2 | ... | mk)
    """
    Bs = [b_of(d) for d in dims]
    Ms = [m_of(d) for d in dims]
    per_stage = [gcd(Bs[i], Ms[i]) == 1 for i in range(len(dims))]
    chain = all(Ms[i + 1] % Ms[i] == 0 for i in range(len(Ms) - 1)) if Ms else True
    return {"Bs": Bs, "Ms": Ms, "per_stage_invertible": per_stage, "divisibility_chain": chain}


def image_size_stage(d: int) -> int:
    """
    |im(v -> b(d)*v mod m(d))| = m(d) / gcd(b(d), m(d)).
    This equals m(d) when the stage is bijective; otherwise it’s strictly smaller.
    """
    b, m = b_of(d), m_of(d)
    return m // gcd(b, m)


# =========================
# Path builders
# =========================

def d_range_for_m(m: int) -> Tuple[int, int]:
    """
    All integers d with m(d) = m satisfy: (m-1)^2 <= d < m^2.
    """
    if m < 1:
        raise ValueError("d_range_for_m: m must be >= 1")
    return (m - 1) * (m - 1), m * m - 1


def find_d_for_m_with_coprime_b(m: int, sample_stride: int = 4000) -> Optional[int]:
    """
    Search for some d in the bucket of m(d)=m with gcd(b(d), m)=1.
    First samples, then (if needed) a dense scan.
    """
    lo, hi = d_range_for_m(m)
    L = hi - lo + 1
    step = max(1, L // max(1, sample_stride))
    # coarse samples
    for d in range(lo, hi + 1, step):
        if gcd(b_of(d), m) == 1:
            return d
    # dense fallback
    for d in range(lo, hi + 1):
        if gcd(b_of(d), m) == 1:
            return d
    return None


def build_lossless_dims(k: int, m_start: int, multiplier: int) -> List[int]:
    """
    Build k dimensions forming a modulus chain m1|m2|...|mk with per-stage gcd(b_i,m_i)=1.

    Raises RuntimeError if no d can be found for some m.
    """
    if k <= 0:
        raise ValueError("k must be positive")
    if m_start < 1 or multiplier < 1:
        raise ValueError("m_start and multiplier must be >= 1")

    dims: List[int] = []
    m = m_start
    for _ in range(k):
        d = find_d_for_m_with_coprime_b(m)
        if d is None:
            raise RuntimeError(f"No suitable d for m={m} (entire bucket had gcd(b(d),m) > 1)")
        dims.append(d)
        m *= multiplier

    # Validate
    Ms = [m_of(d) for d in dims]
    Bs = [b_of(d) for d in dims]
    if not all(Ms[i + 1] % Ms[i] == 0 for i in range(len(Ms) - 1)):
        raise RuntimeError("Divisibility chain failed (m_i does not divide m_{i+1}).")
    if not all(gcd(Bs[i], Ms[i]) == 1 for i in range(len(Ms))):
        raise RuntimeError("Coprime check failed (some stage not invertible).")

    return dims


def build_adaptive_dims(
    k: int, m_start: int, mult_choices: Sequence[int] = (3, 2, 4, 5, 6, 7)
) -> Tuple[List[int], List[int]]:
    """
    Build k dimensions and an **adaptive** modulus chain using small multipliers when a bucket is bad.

    Returns (dims, ms) where:
      dims[i] is the chosen d_i,
      ms[i]   is the chain modulus m_i (a multiple of ms[i-1]).

    Guarantees:
      - m_1 | m_2 | ... | m_k (divisibility chain)
      - gcd(b(d_i), m_i) = 1 for every i

    Raises RuntimeError if it cannot realize a stage.
    """
    if k <= 0:
        raise ValueError("k must be positive")
    if m_start < 1:
        raise ValueError("m_start must be >= 1")
    if not mult_choices:
        raise ValueError("mult_choices must be non-empty")

    dims: List[int] = []
    ms: List[int] = []
    m = m_start

    for i in range(k):
        d = find_d_for_m_with_coprime_b(m)
        if d is None:
            # Try alternative multiples of the previous accepted modulus.
            base = ms[-1] if ms else m_start
            found = False
            for mult in mult_choices:
                m2 = base * mult
                d2 = find_d_for_m_with_coprime_b(m2)
                if d2 is not None:
                    m = m2
                    d = d2
                    found = True
                    break
            if not found:
                raise RuntimeError(f"build_adaptive_dims: failed to realize stage {i+1}")
        dims.append(d)
        ms.append(m)
        # propose next m as a multiple of current; default first multiplier
        m = m * mult_choices[0]

    # Validate guarantees
    if not all(ms[i + 1] % ms[i] == 0 for i in range(len(ms) - 1)):
        raise RuntimeError("Divisibility chain failed (adaptive).")
    if not all(gcd(b_of(dims[i]), ms[i]) == 1 for i in range(len(ms))):
        raise RuntimeError("Coprime check failed (adaptive).")

    return dims, ms


# =========================
# Analysis & testing
# =========================

def test_exact_recovery(dims: Sequence[int], trials: int = 500, seed: Optional[int] = None) -> Dict:
    """
    Empirically estimate exact recovery rate for v ∈ [0, m1-1] by sampling.
    Returns a dict with:
      - exact_rate (float)
      - per_stage_invertible (list of bool)
      - divisibility_chain (bool)
      - Ms, Bs (lists)
      - trials (int)
    """
    if seed is not None:
        random.seed(seed)
    Ms = [m_of(d) for d in dims]
    ok = 0
    for _ in range(trials):
        v = random.randint(0, Ms[0] - 1) if Ms else 0
        t, _ = forward(v, dims)
        vhat, _ = reverse(t, dims)
        ok += int(vhat == v)
    conds = pipeline_conditions(dims)
    return {
        "trials": trials,
        "exact_rate": (ok / trials) if trials else 1.0,
        "per_stage_invertible": conds["per_stage_invertible"],
        "divisibility_chain": conds["divisibility_chain"],
        "Ms": conds["Ms"],
        "Bs": conds["Bs"],
    }


def full_enumeration_recovery(dims: Sequence[int], limit: int = 20000) -> Dict:
    """
    Exhaustively test **all** v ∈ [0, m1-1] if m1 is small enough (<= limit).
    Otherwise, test first 'limit' values and report it's a partial enumeration.

    Returns:
      - domain_size_tested
      - exact_count
      - exact_rate
      - full (bool) whether the full domain was enumerated
    """
    if not dims:
        return {"domain_size_tested": 1, "exact_count": 1, "exact_rate": 1.0, "full": True}

    m1 = m_of(dims[0])
    full = (m1 <= limit)
    tested = m1 if full else min(m1, limit)
    exact = 0
    for v in range(tested):
        t, _ = forward(v, dims)
        vhat, _ = reverse(t, dims)
        if vhat == v:
            exact += 1
    return {
        "domain_size_tested": tested,
        "exact_count": exact,
        "exact_rate": exact / tested if tested else 1.0,
        "full": full,
    }


def audit_table(dims: Sequence[int]) -> List[Dict]:
    """
    Stage-by-stage audit: d, b(d), m(d), gcd(b,m), image_size, invertible?
    """
    rows: List[Dict] = []
    for i, d in enumerate(dims, start=1):
        b, m = b_of(d), m_of(d)
        g = gcd(b, m)
        rows.append({
            "stage": i,
            "d": d,
            "b(d)": b,
            "m(d)": m,
            "gcd(b,m)": g,
            "image_size": m // g,
            "invertible": (g == 1),
        })
    return rows


# =========================
# CLI utilities
# =========================

def _read_dims_from_file(path: str) -> List[int]:
    with open(path, "r", encoding="utf-8") as f:
        obj = json.load(f)
    # Accept either {"dims":[...]} or a raw list
    if isinstance(obj, dict) and "dims" in obj:
        return list(map(int, obj["dims"]))
    if isinstance(obj, list):
        return list(map(int, obj))
    raise ValueError("Unrecognized dims file format (expect a list or an object with 'dims').")


def _maybe_write_json(obj: Dict, out: Optional[str]) -> None:
    if out:
        with open(out, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2)
        print(f"Wrote {out}")


def _maybe_write_csv(rows: List[Dict], csv_path: Optional[str]) -> None:
    if not csv_path:
        return
    # Minimal CSV writer
    import csv
    keys = list(rows[0].keys()) if rows else []
    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=keys)
        w.writeheader()
        for r in rows:
            w.writerow(r)
    print(f"Wrote {csv_path}")


def _print_json(obj: Dict) -> None:
    print(json.dumps(obj, indent=2))


# =========================
# CLI commands
# =========================

def cmd_run(args: argparse.Namespace) -> None:
    if args.dims_from_file:
        dims = _read_dims_from_file(args.dims_from_file)
    elif args.dims:
        dims = list(map(int, args.dims))
    else:
        raise SystemExit("Please provide --dims ... or --dims-from-file FILE.json")

    res = test_exact_recovery(dims, trials=args.trials, seed=args.seed)
    if args.full_enum:
        res["full_enum"] = full_enumeration_recovery(dims, limit=args.enum_limit)
    _print_json({"dims": dims, **res})
    if args.out:
        _maybe_write_json({"dims": dims, **res}, args.out)


def cmd_forward(args: argparse.Namespace) -> None:
    if args.dims_from_file:
        dims = _read_dims_from_file(args.dims_from_file)
    elif args.dims:
        dims = list(map(int, args.dims))
    else:
        raise SystemExit("Please provide --dims ... or --dims-from-file FILE.json")

    t, info = forward(args.v, dims)
    _print_json({"v": args.v, "t": t, "trace": info["trace"]})


def cmd_reverse(args: argparse.Namespace) -> None:
    if args.dims_from_file:
        dims = _read_dims_from_file(args.dims_from_file)
    elif args.dims:
        dims = list(map(int, args.dims))
    else:
        raise SystemExit("Please provide --dims ... or --dims-from-file FILE.json")

    vhat, info = reverse(args.tk, dims)
    _print_json({"tk": args.tk, "v_hat": vhat, **info})


def cmd_build_lossless(args: argparse.Namespace) -> None:
    dims = build_lossless_dims(args.k, args.m_start, args.multiplier)
    obj = {"dims": dims, "Bs": [b_of(d) for d in dims], "Ms": [m_of(d) for d in dims]}
    _print_json(obj)
    _maybe_write_json(obj, args.out)


def cmd_build_adaptive(args: argparse.Namespace) -> None:
    dims, ms = build_adaptive_dims(args.k, args.m_start)
    obj = {"dims": dims, "Ms": ms, "Bs": [b_of(d) for d in dims]}
    _print_json(obj)
    _maybe_write_json(obj, args.out)


def cmd_audit(args: argparse.Namespace) -> None:
    if args.dims_from_file:
        dims = _read_dims_from_file(args.dims_from_file)
    elif args.dims:
        dims = list(map(int, args.dims))
    else:
        raise SystemExit("Please provide --dims ... or --dims-from-file FILE.json")

    rows = audit_table(dims)
    conds = pipeline_conditions(dims)
    report = {
        "dims": dims,
        "Bs": conds["Bs"],
        "Ms": conds["Ms"],
        "per_stage_invertible": conds["per_stage_invertible"],
        "divisibility_chain": conds["divisibility_chain"],
        "stages": rows,
    }
    _print_json(report)
    _maybe_write_csv(rows, args.csv)
    if args.out:
        _maybe_write_json(report, args.out)


def cmd_proofs(args: argparse.Namespace) -> None:
    if args.out:
        with open(args.out, "w", encoding="utf-8") as f:
            f.write(PROOFS)
        print(f"Wrote {args.out}")
    else:
        print(PROOFS)


# =========================
# CLI parser
# =========================

def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="hmgearbox",
        description="HyperMorphic Math Gearbox — dynamic base/modulus transforms with proofs & tools",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    prun = sub.add_parser("run", help="Test exact recovery on a path")
    prun.add_argument("--dims", nargs="*", type=int, help="Dimensions d1 d2 ... dk")
    prun.add_argument("--dims-from-file", help="JSON file with {'dims': [...]} or a raw list")
    prun.add_argument("--trials", type=int, default=500)
    prun.add_argument("--seed", type=int, default=None)
    prun.add_argument("--full-enum", action="store_true", help="Enumerate full domain if feasible")
    prun.add_argument("--enum-limit", type=int, default=20000)
    prun.add_argument("--out", help="Save run result JSON to file")
    prun.set_defaults(func=cmd_run)

    pfwd = sub.add_parser("forward", help="Run forward pipeline")
    pfwd.add_argument("--dims", nargs="*", type=int)
    pfwd.add_argument("--dims-from-file")
    pfwd.add_argument("--v", type=int, required=True)
    pfwd.set_defaults(func=cmd_forward)

    prev = sub.add_parser("reverse", help="Run reverse pipeline")
    prev.add_argument("--dims", nargs="*", type=int)
    prev.add_argument("--dims-from-file")
    prev.add_argument("--tk", type=int, required=True)
    prev.set_defaults(func=cmd_reverse)

    pbll = sub.add_parser("build-lossless", help="Build a lossless chain (m1|...|mk and all gcd=1)")
    pbll.add_argument("--k", type=int, required=True)
    pbll.add_argument("--m-start", type=int, required=True)
    pbll.add_argument("--multiplier", type=int, required=True)
    pbll.add_argument("--out", help="Write JSON to file")
    pbll.set_defaults(func=cmd_build_lossless)

    padp = sub.add_parser("build-adaptive", help="Build an adaptive lossless chain")
    padp.add_argument("--k", type=int, required=True)
    padp.add_argument("--m-start", type=int, required=True)
    padp.add_argument("--out", help="Write JSON to file")
    padp.set_defaults(func=cmd_build_adaptive)

    paud = sub.add_parser("audit", help="Stage-by-stage audit and conditions check")
    paud.add_argument("--dims", nargs="*", type=int)
    paud.add_argument("--dims-from-file")
    paud.add_argument("--csv", help="Save stage audit as CSV")
    paud.add_argument("--out", help="Save full audit JSON to file")
    paud.set_defaults(func=cmd_audit)

    pprf = sub.add_parser("proofs", help="Print or save formal statements & proofs")
    pprf.add_argument("--out", help="Write PROOFS to file")
    pprf.set_defaults(func=cmd_proofs)

    return p


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    args.func(args)
    return 0


# =========================
# Embedded proofs (Markdown)
# =========================

PROOFS = r"""
# Mathematical Proofs — HyperMorphic Math Gearbox

We formalize the **HyperMorphic (HM)** pipeline and prove *when* it is reversible (lossless) and
*when* it is compressive (non-invertible). All integers are understood modulo the given moduli.

---

## Definitions

For a dimension parameter \(d \in \mathbb{Z}_{\ge 1}\), define
\[
b(d) = \lfloor \log_2 d \rfloor + 1, \qquad m(d) = \lfloor \sqrt{d} \rfloor + 1.
\]

A **stage** at dimension \(d\) is the map \(f_d : \mathbb{Z}_{m(d)} \to \mathbb{Z}_{m(d)}\) given by
\[
f_d(v) \equiv b(d)\,v \pmod{m(d)}.
\]

A **pipeline** on a sequence of dimensions \(\mathbf{d}=(d_1,\dots,d_k)\) is the composition
\(
F = f_{d_k}\circ \cdots \circ f_{d_1}.
\)
When needed, write \(m_i = m(d_i)\), \(b_i = b(d_i)\), and \(t_i = f_{d_i}(t_{i-1})\) with \(t_0=v\).

The **reverse step** uses the multiplicative inverse \(b_i^{-1}\ (\mathrm{mod}\ m_i)\), when it exists, to recover
\(t_{i-1}\) from \(t_i\) via \(t_{i-1} \equiv b_i^{-1} t_i\ (\mathrm{mod}\ m_i)\), then reduces to modulus \(m_{i-1}\).

---

## Lemma 1 (Stage bijection)
Let \(d\) be fixed. The map \(f_d(v) \equiv b(d)\,v\ (\mathrm{mod}\ m(d))\) is a bijection on \(\mathbb{Z}_{m(d)}\) **iff**
\(\gcd\big(b(d), m(d)\big)=1\).

**Proof.** The map is multiplication by \(b(d)\) in the ring \(\mathbb{Z}_{m(d)}\). It is invertible iff
\(b(d)\) is a unit, i.e. admits a multiplicative inverse modulo \(m(d)\), which is equivalent to \(\gcd(b(d),m(d))=1\).
\(\square\)

---

## Proposition 2 (Image size and compression factor)
For any stage \(d\), the image size is
\(|\mathrm{im}(f_d)| = \frac{m(d)}{\gcd(b(d), m(d))}\).
In particular, if \(g=\gcd(b(d),m(d))>1\), then \(f_d\) is **many-to-one** with uniform fiber size \(g\).

**Proof.** Multiplication by \(b(d)\) is a group homomorphism of the additive group \((\mathbb{Z}_{m(d)}, +)\) to itself
with kernel of size \(g\). By the first isomorphism theorem, \(|\mathrm{im}| = m(d)/|{\ker}|\) and each fiber has
size \(|{\ker}|=g\). \(\square\)

---

## Theorem 3 (Pipeline recoverability under a modulus chain)
Let \(\mathbf{d}=(d_1,\dots,d_k)\). Assume
1. **Coprime condition:** \(\gcd(b_i, m_i) = 1\) for all \(i=1,\dots,k\).
2. **Divisibility chain:** \(m_1 \mid m_2 \mid \cdots \mid m_k\).

Then the pipeline \(F\) restricts to a **bijection** on the domain \(\mathbb{Z}_{m_1}\).
The reverse algorithm (repeated modular inversion and reduction) recovers \(v\) from \(t_k\) uniquely for all
\(v \in \mathbb{Z}_{m_1}\).

**Proof.** By Lemma 1, each stage \(f_{d_i}\) is a bijection on \(\mathbb{Z}_{m_i}\) with inverse
\(v \mapsto b_i^{-1} v \ (\mathrm{mod}\ m_i)\). Suppose \(t_{i} \in \mathbb{Z}_{m_i}\) is known. Then
\(t_{i-1} \equiv b_i^{-1} t_i \ (\mathrm{mod}\ m_i)\).
Because \(m_{i-1}\mid m_{i}\), reduction to modulus \(m_{i-1}\) is a well-defined homomorphism preserving equality of
residues modulo \(m_{i-1}\). Therefore \(t_{i-1}\) is uniquely recovered in \(\mathbb{Z}_{m_{i-1}}\).
By induction from \(i=k\) down to \(1\), \(t_0=v\) is uniquely recovered in \(\mathbb{Z}_{m_1}\). \(\square\)

---

## Theorem 4 (Two-stage conditional recovery without a full chain)
Consider two stages with parameters \((b_1,m_1)\), \((b_2,m_2)\) and assume \(\gcd(b_1,m_1)=\gcd(b_2,m_2)=1\).
If additionally
\[
b_2^{-1} b_2 \equiv 1 \pmod{m_1},
\]
then the **recovery algorithm succeeds** on \(\mathbb{Z}_{m_1}\) even if \(m_1 \nmid m_2\).

**Proof.** We have \(t_1 \equiv b_1 v \ (\mathrm{mod}\ m_1)\) and \(t_2 \equiv b_2 t_1 \ (\mathrm{mod}\ m_2)\).
Compute \(\tilde t_1 \equiv b_2^{-1} t_2 \ (\mathrm{mod}\ m_2)\).
Reducing \(\tilde t_1\) modulo \(m_1\), we get
\(\tilde t_1 \equiv b_2^{-1} b_2 t_1 \equiv t_1 \ (\mathrm{mod}\ m_1)\) by the assumed congruence.
Then \(v \equiv b_1^{-1} \tilde t_1 \ (\mathrm{mod}\ m_1)\). Hence \(v\) is recovered uniquely in \(\mathbb{Z}_{m_1}\).
\(\square\)

*Remark.* The condition is sufficient but not necessary; it captures a **congruence alignment** that compensates
for the absence of a strict chain.

---

## Corollary 5 (Non-recoverability witness)
If any stage \(i\) has \(\gcd(b_i,m_i)>1\), then the overall pipeline is **not** injective on \(\mathbb{Z}_{m_1}\).
Indeed, the image of \(f_{d_i}\) has size \(m_i / \gcd(b_i,m_i) < m_i\), and the subsequent stages cannot
increase image size beyond \(m_i\), hence distinct inputs collapse.

**Proof.** By Proposition 2 the \(i\)-th stage collapses at least a factor \(\gcd(b_i,m_i)\).
Composition with later maps cannot invert a previous many-to-one collapse. \(\square\)

---

## Complexity (word-RAM model)

- Forward pipeline: \(O(k)\) modular multiplies and reductions.
- Reverse pipeline: \(O(k)\) modular inversions (each via extended Euclid) and reductions.
- Mixed-radix encode/decode: \(O(k)\).
- RNS encode \(O(k)\); CRT decode naive \(O(k^2)\) (or \(O(k \log^2 M)\) with faster methods).

This aligns with empirical results from the test harnesses above.
"""

# =========================
# Entry point
# =========================

if __name__ == "__main__":
    sys.exit(main())
